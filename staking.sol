// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

error TransferFailed();
error NeedsMoreThanZero();
contract staking is ReentrancyGuard{
    IERC20 public s_stakingToken;
    IERC20 public s_rewardsToken;

    // this is reward token per second

    uint256 public constant REWARD_RATE = 100;
    uint256 public s_lastUpdateTime;
    uint256 public s_rewardPerTokenStored;

    mapping(address=>uint256) public s_userRewardPerTokenPaid;
    mapping(address=>uint256) public s_rewards;

    uint256 private s_totalSupply;
    mapping(address=>uint256) public s_balances;

    event Staked(address indexed user,uint256 indexed amount);
    event withdrewStake(address indexed user,uint256 indexed amount);
    event RewardsClaimed(address indexed user,uint256 indexed amount);

    // Staking Token in ERC20 and Rewards Token in Ether in our contract but we can make reverse also
    constructor(address stakingToken,address rewardsToken){
        s_stakingToken=IERC20(stakingToken);
        s_rewardsToken=IERC20(rewardsToken);
    }

    // how much reward a token gets based on how long its in contract 
    function rewardPerToken() public view returns (uint256){
        if(s_totalSupply==0){
            return s_rewardPerTokenStored;
        }
        // Reward is calculated based on total tokens in smart contract
        return s_rewardPerTokenStored+(((block.timestamp-s_lastUpdateTime)*REWARD_RATE*1e18)/s_totalSupply);
    }

    function earned(address account)public view returns(uint256){
        return((s_balances[account]*(rewardPerToken()-s_userRewardPerTokenPaid[account]))/1e18)+s_rewards[account];
    } 

    function stake(uint amount)external  updateReward(msg.sender) nonReentrant moreThanZero(amount){
        s_totalSupply += amount;
        s_balances[msg.sender]+=amount;
        emit Staked(msg.sender, amount);
        // we will use transfer from in dapp as in remix transferfrom as it needs to be approved
        bool success=s_stakingToken.transfer(address(this), amount);
        if(!success){
            revert TransferFailed();
        }
    }

    function withdraw(uint amount)external nonReentrant updateReward(msg.sender){
        s_totalSupply-=amount;
        s_balances[msg.sender]-=amount;
        emit withdrewStake(msg.sender, amount);
        bool success=s_stakingToken.transfer(msg.sender,amount);
        if(!success){
            revert TransferFailed();
        }
    }

    function claimReward()external nonReentrant updateReward(msg.sender){
        uint256 reward=s_rewards[msg.sender];
        s_rewards[msg.sender]=0;
        emit RewardsClaimed(msg.sender,reward);
        bool success=s_rewardsToken.transfer(msg.sender,reward);
        if(!success){
            revert TransferFailed();
        }
    }

    // Modfiers
    modifier updateReward(address account){
        s_rewardPerTokenStored=rewardPerToken();
        s_lastUpdateTime=block.timestamp;
        s_rewards[account]=earned(account);
        s_userRewardPerTokenPaid[account]=s_rewardPerTokenStored;
        _;
    }

    modifier moreThanZero(uint256 amount){
        if(amount==0){
            revert NeedsMoreThanZero();
        }
        _;
    }

    function getStaked(address account)public view returns(uint256){
        return s_balances[account];
    } 
}

// deployed reward token - after deployment,copy the deployed address
// use the deployed address to deploy Staking SC
// paste RT address in constructor of Staking SC twice
// transfer some Reward tokens from owner of RT contract to 3-4 remix amount 
// We will also have to Tranfer some initial ethers to Staking SC as then only it is possible as some TPS is calculated from it
// stake 5000 from RT in 
// Claim reward function can withdraw rewards generated by staking dapp
// withdraw function is used to withdraw staked tokens
